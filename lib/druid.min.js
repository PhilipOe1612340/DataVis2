!function (t, e) {
    "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e((t = "undefined" != typeof globalThis ? globalThis : t || self).druid = t.druid || {})
}(this, (function (t) {
    "use strict";

    function e(t, e) {
        return Math.sqrt(r(t, e))
    }

    function s(t) {
        let e = t.length, s = 0, r = 0;
        for (let i = 0; i < e; ++i) {
            let e = t[i], n = s + e;
            Math.abs(s) >= Math.abs(e) ? r += s - n + e : r += e - n + s, s = n
        }
        return s + r
    }

    function r(t, e) {
        if (t.length != e.length) return;
        let r = t.length, i = new Array(r);
        for (let s = 0; s < r; ++s) {
            let r = t[s], n = e[s];
            i[s] = (r - n) * (r - n)
        }
        return s(i)
    }

    function i(t, s, r = null, i = e) {
        let o = t.length, h = r || n(t, i);
        for (let t = 0; t < o; ++t) h[t] = h[t].map(((e, s) => ({
            i: t,
            j: s,
            distance: h[t][s]
        }))).sort(((t, e) => t.distance - e.distance)).slice(1, s + 1);
        return h
    }

    function n(t, s = e) {
        if (void 0 === s) return;
        let r = t.length, i = new Array(r);
        for (let t = 0; t < r; ++t) i[t] = new Array(r);
        for (let e = 0; e < r; ++e) for (let n = e + 1; n < r; ++n) i[e][n] = i[n][e] = s(t[e], t[n]);
        return i
    }

    function o(t, e, s = null) {
        if (s || (s = Math.max(Math.round(e - t) + 1, 1)), s < 2) return 1 === s ? [t] : [];
        let r = new Array(s);
        for (let i = s -= 1; i >= 0; --i) r[i] = (i * e + (s - i) * t) / s;
        return r
    }

    function h(t, s = e) {
        let r = null;
        if (t instanceof a) {
            let [e, s] = t.shape;
            if (1 === e) r = t.row(0); else {
                if (1 !== s) throw"matrix must be 1d!";
                r = t.col(0)
            }
        } else r = t;
        let i = r.length, n = new Array(i);
        return n.fill(0), s(r, n)
    }

    class a {
        constructor(t = null, e = null, s = null) {
            if (this._rows = t, this._cols = e, this._data = null, t && e) {
                if (!s) return this._data = new Float64Array(t * e), this;
                if ("function" == typeof s) {
                    this._data = new Float64Array(t * e);
                    for (let r = 0; r < t; ++r) for (let t = 0; t < e; ++t) this._data[r * e + t] = s(r, t);
                    return this
                }
                if ("string" == typeof s) {
                    if ("zeros" === s) return new a(t, e, 0);
                    if ("identity" === s || "I" === s) {
                        this._data = new Float64Array(t * e);
                        for (let s = 0; s < t; ++s) this._data[s * e + s] = 1;
                        return this
                    }
                    if ("center" === s && t == e) {
                        this._data = new Float64Array(t * e), s = (e, s) => (e === s ? 1 : 0) - 1 / t;
                        for (let r = 0; r < t; ++r) for (let t = 0; t < e; ++t) this._data[r * e + t] = s(r, t);
                        return this
                    }
                }
                if ("number" == typeof s) {
                    this._data = new Float64Array(t * e);
                    for (let r = 0; r < t; ++r) for (let t = 0; t < e; ++t) this._data[r * e + t] = s;
                    return this
                }
            }
            return this
        }

        static from(t, e = "row") {
            if (t instanceof a) return t.clone();
            if (!(Array.isArray(t) || t instanceof Float64Array)) {
                if ("number" == typeof t) return new a(1, 1, t);
                throw"error"
            }
            {
                let s = t.length;
                if (0 === s) throw"Array is empty";
                if (!(Array.isArray(t[0]) || t[0] instanceof Float64Array)) {
                    if ("row" === e) return new a(1, s, ((e, s) => t[s]));
                    if ("col" === e) return new a(s, 1, (e => t[e]));
                    if ("diag" === e) return new a(s, s, ((e, s) => e == s ? t[e] : 0));
                    throw"1d array has NaN entries"
                }
                if (Array.isArray(t[0]) || t[0] instanceof Float64Array) {
                    let e = t[0].length;
                    for (let r = 0; r < s; ++r) if (t[r].length !== e) throw"various array lengths";
                    return new a(s, e, ((e, s) => t[e][s]))
                }
            }
        }

        row(t) {
            let e = new Array(this._cols);
            for (let s = 0; s < this._cols; ++s) e[s] = this._data[t * this._cols + s];
            return e
        }

        * iterate_rows() {
            const t = this._cols, e = this._rows, s = this._data;
            for (let r = 0; r < e; ++r) yield s.subarray(r * t, (r + 1) * t)
        }

        [Symbol.iterator] = this.iterate_rows;

        set_row(t, e) {
            let s = this._cols;
            if (Array.isArray(e) && e.length === s) {
                let r = t * s;
                for (let t = 0; t < s; ++t) this._data[r + t] = e[t]
            } else if (e instanceof a && e.shape[1] === s && 1 === e.shape[0]) {
                let r = t * s;
                for (let t = 0; t < s; ++t) this._data[r + t] = e._data[t]
            }
            return this
        }

        col(t) {
            let e = new Array(this._rows);
            for (let s = 0; s < this._rows; ++s) e[s] = this._data[s * this._cols + t];
            return e
        }

        entry(t, e) {
            return this._data[t * this._cols + e]
        }

        set_entry(t, e, s) {
            return this._data[t * this._cols + e] = s, this
        }

        transpose() {
            return new a(this._cols, this._rows, ((t, e) => this.entry(e, t)))
        }

        get T() {
            return this.transpose()
        }

        inverse() {
            const t = this._rows, e = this._cols;
            let s = new a(t, 2 * e, ((t, s) => s >= e ? t === s - e ? 1 : 0 : this.entry(t, s))), r = 0, i = 0;
            for (; r < t && i < e;) {
                var n = 0;
                let o = -1 / 0;
                for (let e = r; e < t; ++e) {
                    let t = Math.abs(s.entry(e, i));
                    o < t && (n = e, o = t)
                }
                if (0 == s.entry(n, i)) i++; else {
                    for (let t = 0; t < 2 * e; ++t) {
                        let e = s.entry(r, t), i = s.entry(n, t);
                        s.set_entry(r, t, e), s.set_entry(n, t, i)
                    }
                    for (let n = r + 1; n < t; ++n) {
                        let t = s.entry(n, i) / s.entry(r, i);
                        s.set_entry(n, i, 0);
                        for (let o = i + 1; o < 2 * e; ++o) s.set_entry(n, o, s.entry(n, o) - s.entry(r, o) * t)
                    }
                    r++, i++
                }
            }
            for (let r = 0; r < t; ++r) {
                let t = s.entry(r, r);
                for (let i = r; i < 2 * e; ++i) s.set_entry(r, i, s.entry(r, i) / t)
            }
            for (let r = t - 1; r >= 0; --r) {
                let t = s.entry(r, r);
                for (let i = 0; i < r; i++) {
                    let n = s.entry(i, r) / t;
                    for (let t = i; t < 2 * e; ++t) {
                        let e = s.entry(i, t);
                        e -= s.entry(r, t) * n, s.set_entry(i, t, e)
                    }
                }
            }
            return new a(t, e, ((t, r) => s.entry(t, r + e)))
        }

        dot(t) {
            if (t instanceof a) {
                let e = this;
                if (e.shape[1] !== t.shape[0]) throw`A.dot(B): A is a ${e.shape.join(" x ")}-Matrix, B is a ${t.shape.join(" x ")}-Matrix: \n                A has ${e.shape[1]} cols and B ${t.shape[0]} rows. \n                Must be equal!`;
                let r = e.shape[1];
                return new a(e.shape[0], t.shape[1], ((i, n) => {
                    let o = e.row(i), h = t.col(n);
                    for (let t = 0; t < r; ++t) o[t] *= h[t];
                    return s(o)
                }))
            }
            if (Array.isArray(t) || t instanceof Float64Array) {
                let e = this._rows;
                if (t.length !== e) throw`A.dot(B): A has ${e} cols and B has ${t.length} rows. Must be equal!`;
                let r = new Array(e);
                for (let i = 0; i < e; ++i) r[i] = s(this.row(i).map((e => e * t[i])));
                return r
            }
            throw"B must be Matrix or Array"
        }

        outer(t) {
            let e = this, s = e._data.length;
            if (s != t._data.length) return;
            let r = new a;
            return r.shape = [s, s, (s, i) => s <= i ? e._data[s] * t._data[i] : r.entry(i, s)], r
        }

        concat(t, e = "horizontal") {
            const s = this, [r, i] = s.shape, [n, o] = t.shape;
            if ("horizontal" == e) {
                if (r != n) throw`A.concat(B, "horizontal"): A and B need same number of rows, A has ${r} rows, B has ${n} rows.`;
                const e = new a(r, i + o, "zeros");
                return e.set_block(0, 0, s), e.set_block(0, i, t), e
            }
            if ("vertical" == e) {
                if (i != o) throw`A.concat(B, "vertical"): A and B need same number of columns, A has ${i} columns, B has ${o} columns.`;
                const e = new a(r + n, i, "zeros");
                return e.set_block(0, 0, s), e.set_block(r, 0, t), e
            }
            if ("diag" == e) {
                const e = new a(r + n, i + o, "zeros");
                return e.set_block(0, 0, s), e.set_block(r, i, t), e
            }
            throw`type must be "horizontal" or "vertical", but type is ${e}!`
        }

        set_block(t, e, s) {
            let [r, i] = s.shape;
            for (let n = 0; n < r; ++n) if (!(n > this._rows)) for (let r = 0; r < i; ++r) r > this._cols || this.set_entry(n + t, r + e, s.entry(n, r));
            return this
        }

        get_block(t, e, s = null, r = null) {
            const [i, n] = this.shape;
            if (r = r || n, (s = s || i) <= t || r <= e) throw`\n                end_row must be greater than start_row, and \n                end_col must be greater than start_col, but\n                end_row = ${s}, start_row = ${t}, end_col = ${r}, and start_col = ${e}!`;
            const o = new a(s - t, r - e, "zeros");
            for (let i = t, n = 0; i < s; ++i, ++n) for (let t = e, s = 0; t < r; ++t, ++s) o.set_entry(n, s, this.entry(i, t));
            return o
        }

        _apply_array(t, e) {
            const s = this._data, [r, i] = this.shape;
            for (let n = 0; n < r; ++n) {
                const r = n * i;
                for (let o = 0; o < i; ++o) {
                    const i = r + o, h = s[i];
                    s[i] = t(h, e(n, o))
                }
            }
            return this
        }

        _apply_rowwise_array(t, e) {
            return this._apply_array(e, ((e, s) => t[s]))
        }

        _apply_colwise_array(t, e) {
            const s = this._data, [r, i] = this.shape;
            for (let n = 0; n < r; ++n) {
                const r = n * i;
                for (let o = 0; o < i; ++o) {
                    const i = r + o, h = s[i];
                    s[i] = e(h, t[n])
                }
            }
            return this
        }

        _apply(t, e) {
            let s = this._data;
            if (t instanceof a) {
                let [r, i] = t.shape, [n, o] = this.shape;
                if (1 === r) {
                    if (o !== i) throw"cols !== value_cols";
                    for (let r = 0; r < n; ++r) for (let i = 0; i < o; ++i) s[r * o + i] = e(s[r * o + i], t.entry(0, i))
                } else if (1 === i) {
                    if (n !== r) throw"rows !== value_rows";
                    for (let r = 0; r < n; ++r) for (let i = 0; i < o; ++i) s[r * o + i] = e(s[r * o + i], t.entry(r, 0))
                } else {
                    if (n != r || o != i) throw"error";
                    for (let r = 0; r < n; ++r) for (let i = 0; i < o; ++i) s[r * o + i] = e(s[r * o + i], t.entry(r, i))
                }
            } else if (Array.isArray(t)) {
                let r = this._rows, i = this._cols;
                if (t.length === r) for (let n = 0; n < r; ++n) for (let r = 0; r < i; ++r) s[n * i + r] = e(s[n * i + r], t[n]); else {
                    if (t.length !== i) throw"error";
                    for (let n = 0; n < r; ++n) for (let r = 0; r < i; ++r) s[n * i + r] = e(s[n * i + r], t[r])
                }
            } else for (let r = 0, i = this._rows * this._cols; r < i; ++r) s[r] = e(s[r], t);
            return this
        }

        clone() {
            let t = new a;
            return t._rows = this._rows, t._cols = this._cols, t._data = this._data.slice(0), t
        }

        mult(t) {
            return this.clone()._apply(t, ((t, e) => t * e))
        }

        divide(t) {
            return this.clone()._apply(t, ((t, e) => t / e))
        }

        add(t) {
            return this.clone()._apply(t, ((t, e) => t + e))
        }

        sub(t) {
            return this.clone()._apply(t, ((t, e) => t - e))
        }

        get shape() {
            return [this._rows, this._cols]
        }

        set shape([t, e, s = (() => 0)]) {
            this._rows = t, this._cols = e, this._data = new Float64Array(t * e);
            for (let r = 0; r < t; ++r) for (let t = 0; t < e; ++t) this._data[r * e + t] = s(r, t);
            return this
        }

        get to2dArray() {
            const t = this._rows, e = this._cols;
            let s = new Array(t);
            for (let r = 0; r < t; ++r) {
                let t = new Array(e);
                for (let s = 0; s < e; ++s) t[s] = this.entry(r, s);
                s[r] = t
            }
            return s
        }

        get diag() {
            const t = this._rows, e = this._cols, s = Math.min(t, e);
            let r = new Array(s);
            for (let t = 0; t < s; ++t) r[t] = this.entry(t, t);
            return r
        }

        get mean() {
            const t = this._data, e = this._rows * this._cols;
            let s = 0;
            for (let r = 0; r < e; ++r) s += t[r];
            return s / e
        }

        get meanRows() {
            const t = this._data, e = this._rows, s = this._cols;
            let r = [];
            for (let i = 0; i < e; ++i) {
                r[i] = 0;
                for (let e = 0; e < s; ++e) r[i] += t[i * s + e];
                r[i] /= s
            }
            return r
        }

        get meanCols() {
            const t = this._data, e = this._rows, s = this._cols;
            let r = [];
            for (let i = 0; i < s; ++i) {
                r[i] = 0;
                for (let n = 0; n < e; ++n) r[i] += t[n * s + i];
                r[i] /= e
            }
            return r
        }

        static solve_CG(t, e, s, r = .001) {
            const i = t.shape[0], n = e.shape[1];
            let o = new a(i, 0);
            for (let h = 0; h < n; ++h) {
                let n = new a(i, 1, (() => s.random)), l = a.from(e.col(h)).T.sub(t.dot(n)), _ = l.clone();
                do {
                    const e = t.dot(_), s = l.T.dot(l).entry(0, 0) / _.T.dot(e).entry(0, 0);
                    n = n.add(_.mult(s));
                    const r = l.sub(e.mult(s)), i = r.T.dot(r).entry(0, 0) / l.T.dot(l).entry(0, 0);
                    _ = r.add(_.mult(i)), l = r
                } while (Math.abs(l.mean) > r);
                o = o.concat(n, "horizontal")
            }
            return o
        }

        static solve(t, e) {
            let {L: s, U: r} = "L" in t && "U" in t ? t : a.LU(t), i = s.shape[0], n = e.clone();
            for (let t = 0; t < i; ++t) {
                for (let e = 0; e < t - 1; ++e) n.set_entry(0, t, n.entry(0, t) - s.entry(t, e) * n.entry(1, e));
                n.set_entry(0, t, n.entry(0, t) / s.entry(t, t))
            }
            for (let t = i - 1; t >= 0; --t) {
                for (let e = i - 1; e > t; --e) n.set_entry(0, t, n.entry(0, t) - r.entry(t, e) * n.entry(0, e));
                n.set_entry(0, t, n.entry(0, t) / r.entry(t, t))
            }
            return n
        }

        static LU(t) {
            const e = t.shape[0], s = new a(e, e, "zeros"), r = new a(e, e, "identity");
            for (let i = 0; i < e; ++i) {
                for (let n = i; n < e; ++n) {
                    let e = 0;
                    for (let t = 0; t < i; ++t) e += s.entry(n, t) * r.entry(t, i);
                    s.set_entry(n, i, t.entry(n, i) - e)
                }
                for (let n = i; n < e; ++n) {
                    if (0 === s.entry(i, i)) return;
                    let e = 0;
                    for (let t = 0; t < i; ++t) e += s.entry(i, t) * r.entry(t, n);
                    r.set_entry(i, n, (t.entry(i, n) - e) / s.entry(i, i))
                }
            }
            return {L: s, U: r}
        }

        static SVD(t, e = 2) {
            const s = M.T;
            let r = s.dot(M), i = M.dot(s), {
                eigenvectors: n,
                eigenvalues: o
            } = simultaneous_poweriteration(r, e), {eigenvectors: h} = simultaneous_poweriteration(i, e);
            return {U: h, Sigma: o.map((t => Math.sqrt(t))), V: n}
        }
    }

    class l {
        constructor(t) {
            return this._N = 624, this._M = 397, this._MATRIX_A = 2567483615, this._UPPER_MASK = 2147483648, this._LOWER_MASK = 2147483647, this._mt = new Array(this._N), this._mti = this.N + 1, this.seed = t || (new Date).getTime(), this
        }

        set seed(t) {
            this._seed = t;
            let e = this._mt;
            for (e[0] = t >>> 0, this._mti = 1; this._mti < this._N; this._mti += 1) {
                let t = this._mti, s = e[t - 1] ^ e[t - 1] >>> 30;
                e[t] = (1812433253 * ((4294901760 & s) >>> 16) << 16) + 1812433253 * (65535 & s) + t, e[t] >>>= 0
            }
        }

        get seed() {
            return this._seed
        }

        get random() {
            return this.random_int * (1 / 4294967296)
        }

        get random_int() {
            let t, e = new Array(0, this._MATRIX_A);
            if (this._mti >= this._N) {
                let s;
                this._mti == this._N + 1 && (this.seed = 5489);
                let r = this._N - this._M, i = this._M - this._N;
                for (s = 0; s < r; ++s) t = this._mt[s] & this._UPPER_MASK | this._mt[s + 1] & this._LOWER_MASK, this._mt[s] = this._mt[s + this._M] ^ t >>> 1 ^ e[1 & t];
                for (; s < this._N - 1; ++s) t = this._mt[s] & this._UPPER_MASK | this._mt[s + 1] & this._LOWER_MASK, this._mt[s] = this._mt[s + i] ^ t >>> 1 ^ e[1 & t];
                t = this._mt[this._N - 1] & this._UPPER_MASK | this._mt[0] & this._LOWER_MASK, this._mt[this._N - 1] = this._mt[this._M - 1] ^ t >>> 1 ^ e[1 & t], this._mti = 0
            }
            return t = this._mt[this._mti += 1], t ^= t >>> 11, t ^= t << 7 & 2636928640, t ^= t << 15 & 4022730752, t ^= t >>> 18, t >>> 0
        }

        choice(t, e) {
            if (t instanceof a) {
                let [s, r] = t.shape;
                if (e > s) throw"n bigger than A!";
                let i = new Array(e), n = o(0, s - 1);
                for (let t = 0, s = n.length; t < e; ++t, --s) {
                    let e = this.random_int % s;
                    i[t] = n.splice(e, 1)[0]
                }
                return i.map((e => t.row(e)))
            }
            if (Array.isArray(t) || t instanceof Float64Array) {
                let s = t.length;
                if (e > s) throw"n bigger than A!";
                let r = new Array(e), i = o(0, s - 1);
                for (let t = 0, s = i.length; t < e; ++t, --s) {
                    let e = this.random_int % s;
                    r[t] = i.splice(e, 1)[0]
                }
                return r.map((e => t[e]))
            }
        }

        static choice(t, e, s = 19870307) {
            let [r, i] = t.shape;
            if (e > r) throw"n bigger than A!";
            let n = new l(s), h = new Array(e), a = o(0, r - 1);
            for (let t = 0, s = a.length; t < e; ++t, --s) {
                let e = n.random_int % s;
                h[t] = a.splice(e, 1)[0]
            }
            return h.map((e => t.row(e)))
        }
    }

    class _ {
        constructor(t = null, e = (t => t), s = "min") {
            return t ? _.heapify(t, e, s) : (this._accessor = e, this._container = [], this._comparator = "min" == s ? (t, e) => t < e : "max" == s ? (t, e) => t > e : s, this)
        }

        static heapify(t, e = (t => t), s = "min") {
            const r = new _(null, e, s), i = r._container;
            for (const s of t) i.push({element: s, value: e(s)});
            for (let e = Math.floor(t.length / 2 - 1); e >= 0; --e) r._heapify_down(e);
            return r
        }

        _swap(t, e) {
            const s = this._container;
            [s[e], s[t]] = [s[t], s[e]]
        }

        _heapify_up() {
            const t = this._container;
            let e = t.length - 1;
            for (; e > 0;) {
                let s = Math.floor((e - 1) / 2);
                if (!this._comparator(t[e].value, t[s].value)) break;
                this._swap(s, e), e = s
            }
        }

        push(t) {
            const e = {element: t, value: this._accessor(t)};
            return this._container.push(e), this._heapify_up(), this
        }

        _heapify_down(t = 0) {
            const e = this._container, s = this._comparator, r = e.length;
            let i = 2 * t + 1, n = 2 * t + 2, o = t;
            if (o > r) throw"index higher than length";
            i < r && s(e[i].value, e[o].value) && (o = i), n < r && s(e[n].value, e[o].value) && (o = n), o !== t && (this._swap(t, o), this._heapify_down(o))
        }

        pop() {
            const t = this._container;
            if (0 === t.length) return null;
            if (1 === t.length) return t.pop();
            this._swap(0, t.length - 1);
            const e = t.pop();
            return this._heapify_down(), e
        }

        get first() {
            return this._container.length > 0 ? this._container[0] : null
        }

        * iterate() {
            for (let t = 0, e = this._container.length; t < e; ++t) yield this._container[t].element
        }

        toArray() {
            return this.data().sort(((t, e) => this._comparator(t, e) ? -1 : 0))
        }

        data() {
            return this._container.map((t => t.element))
        }

        raw_data() {
            return this._container
        }

        get length() {
            return this._container.length
        }

        get empty() {
            return 0 === this.length
        }
    }

    class c {
        constructor(t = null, s = e) {
            return this._Node = class {
                constructor(t, e = null, s = null, r = null) {
                    this.pivot = t, this.child1 = e, this.child2 = s, this.radius = r
                }
            }, this._Leaf = class {
                constructor(t) {
                    this.points = t
                }
            }, this._metric = s, t && this.add(t), this
        }

        add(t) {
            return t = t.map(((t, e) => ({index: e, element: t}))), this._root = this._construct(t), this
        }

        _construct(t) {
            if (1 === t.length) return new this._Leaf(t);
            {
                let e, s = this._greatest_spread(t), r = t.sort(((t, e) => t.element[s] - e.element[s])), i = r.length,
                    n = Math.floor(i / 2), o = t[n], h = r.slice(0, n), a = r.slice(n, i),
                    l = Math.max(...t.map((t => this._metric(o.element, t.element))));
                return e = h.length > 0 && a.length > 0 ? new this._Node(o, this._construct(h), this._construct(a), l) : new this._Leaf(t), e
            }
        }

        _greatest_spread(t) {
            let e = t[0].element.length, s = new Array(e);
            for (let t = 0; t < e; ++t) s[t] = [1 / 0, -1 / 0];
            let r = t.reduce(((t, s) => {
                for (let r = 0; r < e; ++r) t[r][0] = Math.min(t[r][0], s.element[r]), t[r][1] = Math.max(t[r][1], s.element[r]);
                return t
            }), s);
            r = r.map((t => t[1] - t[0]));
            let i = 0;
            for (let t = 0; t < e; ++t) i = r[t] > r[i] ? t : i;
            return i
        }

        search(t, e = 5) {
            return this._search(t, e, new _(null, (e => this._metric(e.element, t)), "max"), this._root)
        }

        _search(t, e, s, r) {
            if (s.length >= e && r.pivot && r.radius && this._metric(t, r.pivot.element) - r.radius >= s.first.value) return s;
            if (r.child1 && this._search(t, e, s, r.child1), r.child2 && this._search(t, e, s, r.child2), r.points) for (let t = 0, i = r.points.length; t < i; ++t) {
                let i = r.points[t];
                e > s.length ? s.push(i) : (s.push(i), s.pop())
            }
            return s
        }
    }

    function u(t) {
        const [r, i] = t.shape, n = new a(r, i, "identity"), o = new a(i, i, 0);
        for (let a = 0; a < i; ++a) {
            let i = t.col(a);
            for (let t = 0; t < a; ++t) {
                const e = n.col(t), r = s(e.map(((t, e) => t * i[e])));
                o.set_entry(t, a, r), i = i.map(((t, s) => t - r * e[s]))
            }
            const l = h(i, e);
            for (let t = 0; t < r; ++t) n.set_entry(t, a, i[t] / l);
            o.set_entry(a, a, l)
        }
        return {R: o, Q: n}
    }

    function f(t, e = 2, r = 100, i = 1212) {
        let n;
        n = i instanceof l ? i : new l(i), t instanceof a || (t = a.from(t));
        let o = t.shape[0], {Q: h, R: _} = u(new a(o, e, (() => n.random)));
        for (; r--;) {
            let e = _.clone(), i = u(t.dot(h));
            [h, _] = [i.Q, i.R], s(_.sub(e).diag) / o < 1e-12 && (r = 0)
        }
        return {eigenvalues: _.diag, eigenvectors: h.transpose().to2dArray}
    }

    class d {
        get parameter_list() {
            return this._parameter_list
        }

        set parameter_list(t) {
            return this._parameter_list = t, this
        }

        constructor(t, s = 2, r = e, i = 1212) {
            if (Array.isArray(t)) this._type = "array", this.X = a.from(t); else {
                if (!(t instanceof a)) throw"no valid type for X";
                this._type = "matrix", this.X = t
            }
            return [this._N, this._D] = this.X.shape, this._d = s, this._metric = r, this._seed = i, this._randomizer = new l(i), this._is_initialized = !1, this
        }

        parameter(t, e = null) {
            if (-1 === this.parameter_list.findIndex((e => e === t))) throw t + " is not a valid parameter!";
            return e ? (this["_" + t] = e, this) : this["_" + t]
        }

        para(t, e = null) {
            return this.parameter(t, e)
        }

        p(t, e = null) {
            return this.parameter(t, e)
        }

        transform() {
            return this.check_init(), this.Y
        }

        check_init() {
            this._is_initialized || "function" != typeof this.init || (this.init(), this._is_initialized = !0)
        }

        get projection() {
            return "matrix" === this._type ? this.Y : this.Y.to2dArray
        }

        async transform_async() {
            return this.transform()
        }

        static transform(...t) {
            return new this(...t).transform()
        }

        static async transform_async(...t) {
            return this.transform(...t)
        }

        static* generator(...t) {
            const e = new this(...t).generator();
            for (const t of e) yield t
        }
    }

    class p extends d {
        constructor(t, e = 2) {
            return super(t, e), this
        }

        transform() {
            let t = this.X, e = t.shape[1], s = new a(e, e, "center"), r = t.dot(s),
                i = r.transpose().dot(r), {eigenvectors: n} = f(i, this._d);
            return n = a.from(n).transpose(), this.Y = t.dot(n), this.projection
        }
    }

    class m extends d {
        constructor(t, s = 2, r = e, i = 1212) {
            return super(t, s, r, i), this
        }

        transform() {
            const t = this.X, e = t.shape[0], s = this._metric;
            let r = [], i = [];
            for (let t = 0; t < e; ++t) r.push(0), i.push(0);
            let n = 0;
            const o = new a;
            o.shape = [e, e, (e, h) => {
                let a = 0;
                return e < h ? a = s(t.row(e), t.row(h)) : e > h && (a = o.entry(h, e)), r[e] += a, i[h] += a, n += a, a
            }], this._d_X = o, r = r.map((t => t / e)), i = i.map((t => t / e)), n /= e ** 2;
            const h = new a(e, e, ((t, e) => o.entry(t, e) - r[t] - i[e] + n)), {eigenvectors: l} = f(h, this._d);
            return this.Y = a.from(l).transpose(), this.projection
        }

        get stress() {
            const t = this.X.shape[0], s = this.Y, r = this._d_X, i = new a;
            i.shape = [t, t, (t, r) => t < r ? e(s.row(t), s.row(r)) : i.entry(r, t)];
            let n = 0, o = 0;
            for (let e = 0; e < t; ++e) for (let s = e + 1; s < t; ++s) n += Math.pow(r.entry(e, s) - i.entry(e, s), 2), o += Math.pow(r.entry(e, s), 2);
            return Math.sqrt(n / o)
        }
    }

    function y(t, e, s = 300) {
        const r = e.length;
        let i = .001, n = 1e4, o = e.slice(), h = t(o), a = !1;
        for (; s-- >= 0 && !a;) {
            a = !0;
            for (let e = 0; e < r; ++e) {
                o[e] += 1e-6;
                let s = t(o);
                o[e] -= 1e-6;
                let r = (s - h) / 1e-6;
                Math.abs(r) > .01 && (a = !1), o[e] -= i * r, h = t(o)
            }
            i *= n >= h ? 1.05 : .4, n = h
        }
        return o
    }

    class w {
        constructor(t, e, s, r, i, n, o, h) {
            return this.id = t, this.left = e, this.right = s, this.dist = r, this.index = n, this.size = null != o ? o : e.size + s.size, this.depth = null != h ? h : 1 + Math.max(e.depth, s.depth), this.centroid = null != i ? i : this._calculate_centroid(e, s), this
        }

        _calculate_centroid(t, e) {
            const s = t.size, r = e.size, i = t.centroid, n = e.centroid, o = this.size, h = t.centroid.length,
                a = new Float64Array(h);
            for (let t = 0; t < h; ++t) a[t] = (s * i[t] + r * n[t]) / o;
            return a
        }

        get isLeaf() {
            return 0 === this.depth
        }

        leaves() {
            if (this.isLeaf) return [this.index];
            const t = this.left, e = this.right;
            return (t.isLeaf ? [t.index] : t.leaves()).concat(e.isLeaf ? [e.index] : e.leaves())
        }
    }

    class g {
        constructor(t, s, r = null, i = e, n = 1212) {
            this._metric = i, this._matrix = t, this._A = this._matrix.to2dArray, this._K = s;
            const [o, h] = t.shape;
            return this._N = o, this._D = h, this._max_iter = r || 10 * Math.log10(o), this._distance_matrix = new a(o, o, "zeros"), s > o && (s = o), this._randomizer = new l(n), this._clusters = new Array(o).fill(void 0), this._cluster_medoids = this._get_random_medoids(s), this._is_initialized = !1, this
        }

        get_clusters() {
            const t = this._K, e = this._A;
            this._is_initialized || this.init(t, this._cluster_medoids);
            const s = new Array(t).fill().map((() => new Array));
            return e.forEach(((t, e) => {
                s[this._nearest_medoid(t, e).index_nearest].push(e)
            })), s.medoids = this._cluster_medoids, s
        }

        async* generator() {
            const t = this._max_iter;
            yield this.get_clusters();
            let e = !1, s = 0;
            do {
                e = this._iteration(), yield this.get_clusters()
            } while (!e && ++s < t)
        }

        _iteration() {
            const t = this._A, e = this._K, s = this._cluster_medoids,
                r = t.map(((t, e) => this._nearest_medoid(t, e))), i = new Array(e).fill(0),
                n = new Array(e).fill(null);
            if (t.forEach(((o, h) => {
                if (s.findIndex((t => t === h)) < 0) {
                    const s = r[h].distance_nearest, a = new Array(e).fill(-s);
                    t.forEach(((t, s) => {
                        if (h === s) return;
                        const i = this._get_distance(s, h, t, o), {
                            index_nearest: n,
                            distance_nearest: l,
                            distance_second: _
                        } = r[s];
                        if (a[n] += Math.min(i, _) - l, i < l) for (let t = 0; t < e; ++t) t !== n && (a[t] += i - l)
                    })), a.map(((t, e) => [t, e])).filter((([t, e]) => t < i[e])).forEach((([t, e]) => {
                        t < i[e] && (i[e] = t, n[e] = h)
                    }))
                }
            })), Math.min(...i) >= 0) return !0;
            for (; Math.min(...i) < 0;) {
                const e = i.map(((t, e) => [t, e])).sort((([t], [e]) => t - e))[0][1];
                0 == s.filter((t => t == n[e])).length && (s[e] = n[e]), i[e] = 0, i.map(((t, e) => [t, e])).filter((([t]) => t < 0)).forEach((([n, o]) => {
                    const h = t[o];
                    let a = 0;
                    t.forEach(((t, i) => {
                        s.findIndex((t => t != o && t == i)) >= 0 || e != o && (r[i].index_nearest === s[o] ? a += Math.min(this._get_distance(i, o, t, h), r[i].distance_second) - r[i].distance_nearest : a += Math.min(this._get_distance(i, o, t, h) - r[i].distance_nearest, 0))
                    })), i[o] = a
                }))
            }
            return this._cluster_medoids = s, !1
        }

        _get_distance(t, e, s = null, r = null) {
            if (t === e) return 0;
            const i = this._distance_matrix, n = this._A, o = this._metric;
            let h = i.entry(t, e);
            return 0 === h && (h = o(s || n[t], r || n[e]), i.set_entry(t, e, h), i.set_entry(e, t, h)), h
        }

        _nearest_medoid(t, e) {
            const s = this._cluster_medoids, r = this._A, [i, n] = s.map(((s, i) => {
                const n = r[s];
                return [this._get_distance(e, s, t, n), i]
            })).sort(((t, e) => t[0] - e[0]));
            return {distance_nearest: i[0], index_nearest: i[1], distance_second: n[0], index_second: n[1]}
        }

        init(t, e) {
            t || (t = this._K), e || (e = this._get_random_medoids(t));
            const s = this._max_iter;
            let r = !1, i = 0;
            do {
                r = this._iteration()
            } while (!r && ++i < s);
            return this
        }

        _get_random_medoids(t) {
            const e = this._N, s = this._A, r = o(0, e - 1), i = this._randomizer,
                n = Math.min(e, 10 + Math.ceil(Math.sqrt(e))), h = new Array(n).fill(1 / 0), a = [];
            let l = 1 / 0, _ = i.choice(r, n);
            for (let t = 0; t < n; ++t) {
                const e = _[t], r = s[e];
                for (let e = 0; e < n; ++e) {
                    if (e === t) continue;
                    const i = s[_[e]];
                    h[t] += this._get_distance(t, e, r, i)
                }
                h[t] < l && (l = h[t], a.push(e))
            }
            for (let e = 1; e < t; ++e) {
                let t = 1 / 0;
                _ = i.choice(r.filter((t => a.findIndex((e => e === t)) < 0)), n);
                for (let e = 0; e < n; ++e) {
                    let r = 0;
                    const i = _[e], o = s[i];
                    for (let t = 0; t < n; ++t) {
                        if (t === e) continue;
                        const n = _[t], h = s[n];
                        let l = this._get_distance(i, n, o, h) - Math.min(...a.map((t => this._get_distance(n, t, h))));
                        l < 0 && (r += l)
                    }
                    r < t && (t = r, a.push(i))
                }
                l += t
            }
            return a.slice(0, t)
        }
    }

    class A {
        constructor(t = null) {
            if (this._list = new Set, t) for (const e of t) this.make_set(e);
            return this
        }

        make_set(t) {
            const e = this._list;
            return e.has(t) || (e.add(t), t.__disjoint_set = {}, t.__disjoint_set.parent = t, t.__disjoint_set.children = new Set([t]), t.__disjoint_set.size = 1), this
        }

        find(t) {
            return this._list.has(t) ? t.__disjoint_set.parent !== t ? (t.__disjoint_set.children.add(...t), t.__disjoint_set.parent = this.find(t.__disjoint_set.parent), t.__disjoint_set.parent) : t : null
        }

        union(t, e) {
            let s = this.find(t), r = this.find(e);
            return s === r || (s.__disjoint_set.size < r.__disjoint_set.size && ([s, r] = [r, s]), r.__disjoint_set.parent = s, r.__disjoint_set.children.forEach(s.__disjoint_set.children.add, s.__disjoint_set.children), s.__disjoint_set.size += r.__disjoint_set.size), this
        }
    }

    t.BallTree = c, t.FASTMAP = class extends d {
        constructor(t, s = 2, r = e, i = 1212) {
            return super(t, s, r, i), this
        }

        _choose_distant_objects(t) {
            const e = this.X.shape[0];
            let s = this._randomizer.random_int % e - 1, r = null, i = -1 / 0;
            for (let n = 0; n < e; ++n) {
                const e = t(s, n);
                e > i && (i = e, r = n)
            }
            i = -1 / 0;
            for (let n = 0; n < e; ++n) {
                const e = t(r, n);
                e > i && (i = e, s = n)
            }
            return [s, r, i]
        }

        transform() {
            const t = this.X, e = t.shape[0], s = this._d, r = this._metric, i = new a(e, s, 0);
            let n = (e, s) => r(t.row(e), t.row(s));
            for (let t = 0; t < s; ++t) {
                let s = n;
                const [r, o, h] = this._choose_distant_objects(n);
                if (0 !== h) {
                    for (let s = 0; s < e; ++s) {
                        const e = (n(r, s) ** 2 + h ** 2 - n(o, s) ** 2) / (2 * h);
                        i.set_entry(s, t, e)
                    }
                    n = (e, r) => Math.sqrt(s(e, r) ** 2 - (i.entry(e, t) - i.entry(r, t)) ** 2)
                }
            }
            return this.Y = i, this.projection
        }
    }, t.Heap = _, t.Hierarchical_Clustering = class {
        constructor(t, s = "single", r = e) {
            return this._id = 0, this._matrix = t, this._metric = r, this._linkage = s, this.init(), this.root = this.do(), this
        }

        get_clusters(t, e = "distance") {
            let s, r = [];
            switch (e) {
                case"distance":
                    s = t => t.dist;
                    break;
                case"depth":
                    s = t => t.depth;
                    break;
                default:
                    throw"invalid type"
            }
            return this._traverse(this.root, s, t, r), r
        }

        _traverse(t, e, s, r) {
            e(t) <= s ? r.push(t.leaves()) : (this._traverse(t.left, e, s, r), this._traverse(t.right, e, s, r))
        }

        init() {
            const t = this._metric, e = this._matrix, s = this._n = e.shape[0], r = this._d_min = new Float64Array(s),
                i = this._distance_matrix = new Array(s);
            for (let n = 0; n < s; ++n) {
                r[n] = 0, i[n] = new Float64Array(s);
                for (let o = 0; o < s; ++o) i[n][o] = n === o ? 1 / 0 : t(e.row(n), e.row(o)), i[n][r[n]] > i[n][o] && (r[n] = o)
            }
            const n = this._clusters = new Array(s), o = this._c_size = new Uint16Array(s);
            for (let t = 0; t < s; ++t) n[t] = [], n[t][0] = new w(this._id++, null, null, 0, e.row(t), t, 1, 0), o[t] = 1;
            return this
        }

        do() {
            const t = this._n, e = this._d_min, s = this._distance_matrix, r = this._clusters, i = this._c_size,
                n = this._linkage;
            let o = null;
            for (let h = 0, a = t - 1; h < a; ++h) {
                let h = 0;
                for (let r = 0; r < t; ++r) s[r][e[r]] < s[h][e[h]] && (h = r);
                let a = e[h], l = r[h][0], _ = r[a][0], c = new w(this._id++, l, _, s[h][a]);
                r[h].unshift(c), i[h] += i[a];
                for (let e = 0; e < t; ++e) switch (n) {
                    case"single":
                        s[h][e] > s[a][e] && (s[e][h] = s[h][e] = s[a][e]);
                        break;
                    case"complete":
                        s[h][e] < s[a][e] && (s[e][h] = s[h][e] = s[a][e]);
                        break;
                    case"average":
                        s[e][h] = s[h][e] = (i[h] * s[h][e] + i[a] * s[a][e]) / (i[h] + i[e])
                }
                s[h][h] = 1 / 0;
                for (let e = 0; e < t; ++e) s[e][a] = s[a][e] = 1 / 0;
                for (let r = 0; r < t; ++r) e[r] === a && (e[r] = h), s[h][r] < s[h][e[h]] && (e[h] = r);
                o = c
            }
            return o
        }
    }, t.ISOMAP = class extends d {
        constructor(t, s, r = 2, i = e, n = 1212) {
            return super(t, r, i, n), super.parameter_list = ["k"], this.parameter("k", Math.min(s ?? Math.max(Math.floor(this.X.shape[0] / 10), 2), this._N - 1)), this
        }

        transform() {
            let t = this.X, e = t.shape[0], s = new a;
            s.shape = [e, e, (e, r) => e <= r ? this._metric(t.row(e), t.row(r)) : s.entry(r, e)];
            let r = [];
            for (let t = 0; t < e; ++t) {
                let e = s.row(t).map(((t, e) => ({index: e, distance: t}))), i = new _(e, (t => t.distance), "min");
                r.push(i.toArray().slice(1, this._k + 1))
            }
            let i = new a(e, e, ((t, e) => {
                let s = r[t].find((t => t.index === e));
                return s ? s.distance : 1 / 0
            }));
            for (let t = 0; t < e; ++t) for (let s = 0; s < e; ++s) for (let r = 0; r < e; ++r) i.set_entry(t, s, Math.min(i.entry(t, s), i.entry(t, r) + i.entry(r, s)));
            let n = [], o = [];
            for (let t = 0; t < e; ++t) n.push(0), o.push(0);
            let h = 0, l = new a(e, e, ((t, e) => {
                let s = i.entry(t, e);
                return s = s === 1 / 0 ? 0 : s, n[t] += s, o[e] += s, h += s, s
            }));
            n = n.map((t => t / e)), o = o.map((t => t / e)), h /= e ** 2;
            let c = new a(e, e, ((t, e) => l.entry(t, e) - n[t] - o[e] + h)), {eigenvectors: u} = f(c, this._d);
            return this.Y = a.from(u).transpose(), this.projection
        }

        parameter(t, e = null) {
            return super.parameter(t, e)
        }

        para(t, e = null) {
            return this.parameter(t, e)
        }

        p(t, e = null) {
            return this.parameter(t, e)
        }
    }, t.KMeans = class {
        constructor(t, s, r = e, i = 1987, n = !0) {
            this._metric = r, this._matrix = t, this._K = s;
            const [o, h] = t.shape;
            return this._N = o, this._D = h, s > o && (s = o), this._randomizer = new l(i), this._clusters = new Array(o).fill(void 0), this._cluster_centroids = this._get_random_centroids(s), n && this.init(s, this._cluster_centroids), this
        }

        get_clusters() {
            const t = this._K, e = this._clusters, s = new Array(t).fill().map((() => new Array));
            return e.forEach(((t, e) => s[t].push(e))), s
        }

        _furthest_point(t, e) {
            const s = this._matrix, r = this._metric;
            let i = t.length;
            return _.heapify(e, (e => {
                const n = s.row(e);
                let o = 0;
                for (let e = 0; e < i; ++e) o += r(n, t[e]);
                return o
            }), "max").pop().element
        }

        _get_random_centroids(t) {
            const e = this._N, s = this._randomizer, r = this._matrix, i = new Array(t).fill(), n = o(0, e - 1),
                h = s.random_int % (e - 1);
            i[0] = r.row(h);
            const a = [h], l = Math.floor((e - t) / t);
            for (let e = 1; e < t; ++e) {
                const t = s.choice(n.filter((t => -1 == a.indexOf(t))), l), o = this._furthest_point(i.slice(0, e), t);
                a.push(o), i[e] = r.row(o)
            }
            return i
        }

        _iteration(t) {
            const e = t.length, s = this._N, r = this._D, i = this._matrix, n = this._metric, o = this._clusters;
            let h = !1;
            for (let r = 0; r < s; ++r) {
                const s = i.row(r);
                let a = 1 / 0, l = null;
                for (let r = 0; r < e; ++r) {
                    let e = n(t[r], s);
                    e < a && (a = e, l = r)
                }
                o[r] !== l && (h = !0), o[r] = l
            }
            for (let s = 0; s < e; ++s) {
                const e = t[s];
                for (let t = 0; t < r; ++t) e[t] = 0
            }
            return this._compute_centroid(t), {clusters_changed: h, cluster_centroids: t}
        }

        _compute_centroid(t) {
            const e = t.length, s = this._N, r = this._D, i = this._matrix, n = this._clusters,
                o = new Array(e).fill(0);
            for (let e = 0; e < s; ++e) {
                const s = i.row(e), h = n[e];
                o[h]++;
                const a = t[h];
                for (let t = 0; t < r; ++t) a[t] += s[t]
            }
            for (let s = 0; s < e; ++s) {
                const e = o[s];
                t[s] = t[s].map((t => t / e))
            }
        }

        init(t, e) {
            t || (t = this._K), e || (e = this._get_random_centroids(t));
            let s = !1;
            do {
                const t = this._iteration(e);
                e = t.cluster_centroids, s = t.clusters_changed
            } while (s)
        }
    }, t.KMedoids = g, t.LDA = class extends d {
        constructor(t, s, r = 2, i = e, n = 1212) {
            return super(t, r, i, n), super.parameter_list = ["labels"], this.parameter("labels", s), this
        }

        transform() {
            let t = this.X, [e, s] = t.shape, r = this._labels, i = {}, n = 0;
            r.forEach(((e, s) => {
                e in i ? (i[e].count++, i[e].rows.push(t.row(s))) : i[e] = {id: n++, count: 1, rows: [t.row(s)]}
            }));
            let o = t.mean, h = new a(n, s);
            for (let t in i) {
                let e = a.from(i[t].rows).meanCols;
                for (let r = 0; r < s; ++r) h.set_entry(i[t].id, r, e[r])
            }
            let l = new a(s, s);
            for (let t in i) {
                let e = h.row(i[t].id), r = new a(s, 1, (t => e[t] - o)), n = i[t].count;
                l = l.add(r.dot(r.transpose()).mult(n))
            }
            let _ = new a(s, s);
            for (let t in i) {
                let e = h.row(i[t].id), r = new a(s, 1, (t => e[t])), n = i[t].rows;
                for (let e = 0, o = i[t].count; e < o; ++e) {
                    let t = new a(s, 1, ((t, s) => n[e][t] - r.entry(t, 0)));
                    _ = _.add(t.dot(t.transpose()))
                }
            }
            let {eigenvectors: c} = f(_.inverse().dot(l), this._d);
            return c = a.from(c).transpose(), this.Y = t.dot(c), this.projection
        }
    }, t.LLE = class extends d {
        constructor(t, s, r = 2, i = e, n = 1212) {
            return super(t, r, i, n), super.parameter_list = ["k"], this.parameter("k", Math.min(s ?? Math.max(Math.floor(this._N / 10), 2), this._N - 1)), this
        }

        transform() {
            const t = this.X, e = this._d, [r, n] = t.shape, o = this._k, h = i(t.to2dArray, o, null, this._metric),
                l = new a(o, 1, 1), _ = new a(r, r);
            for (let e = 0; e < r; ++e) {
                const r = new a(o, n, ((s, r) => t.entry(h[e][s].j, r) - t.entry(e, r))), i = r.dot(r.transpose());
                if (o > n) {
                    const t = s(i.diag) / 1e3;
                    for (let e = 0; e < o; ++e) i.set_entry(e, e, i.entry(e, e) + t)
                }
                let c = a.solve(i, l);
                const u = s(c.col(0));
                c = c.divide(u);
                for (let t = 0; t < o; ++t) _.set_entry(e, h[e][t].j, c.entry(t, 0))
            }
            const c = new a(r, r, "identity").sub(_),
                u = c.transpose().dot(c), {eigenvectors: d} = f(u.transpose().inverse(), e + 1);
            return this.Y = a.from(d.slice(1, 1 + e)).transpose(), this.projection
        }
    }, t.LSP = class extends d {
        constructor(t, s, r, i = 2, n = e, o = 1212) {
            return super(t, i, n, o), super.parameter_list = ["k", "control_points"], this.parameter("k", Math.min(s || Math.max(Math.floor(this.X.shape[0] / 10), 2), this._N - 1)), this.parameter("control_points", Math.min(r || Math.ceil(Math.sqrt(this._N)), this._N - 1)), this._is_initialized = !1, this
        }

        init(t = m, e = [], s = c) {
            if (this._is_initialized) return;
            const r = this.X, i = this._N, n = this.parameter("k"), o = this._d, h = this._metric,
                l = this.parameter("control_points"), _ = new g(r, l, null, h).get_clusters().medoids,
                u = new a(l, i, "zeros");
            _.forEach(((t, e) => {
                u.set_entry(e, t, 1)
            }));
            const f = new t(a.from(_.map((t => r.row(t)))), ...e, o).transform(), d = r.to2dArray, p = new s(d, h),
                y = new a(i, i, "I"), w = -1 / n;
            d.forEach(((t, e) => {
                for (const {index: s} of p.search(t, n).iterate()) e !== s && y.set_entry(e, s, w)
            }));
            const A = y.concat(u, "vertical"), x = new a(i, o, "zeros").concat(f, "vertical");
            return this._A = A, this._b = x, this._is_initialized = !0, this
        }

        transform() {
            this._is_initialized || this.init();
            const t = this._A, e = t.T, s = this._b, r = e.dot(t), i = e.dot(s);
            return this.Y = a.solve_CG(r, i, this._randomizer), this.projection
        }
    }, t.LTSA = class extends d {
        constructor(t, s, r = 2, i = e, n = 1212) {
            if (super(t, r, i, n), super.parameter_list = ["k"], this.parameter("k", Math.min(s ?? Math.max(Math.floor(this._N / 10), 2), this._N - 1)), this._D <= r) throw`Dimensionality of X (D = ${this._D}) must be greater than the required dimensionality of the result (d = ${r})!`;
            return this
        }

        transform() {
            const t = this.X, e = this._d, [s, r] = t.shape, n = this._k, o = i(t.to2dArray, n, null, this._metric),
                h = new a(r, r, "center"), l = new a(s, s, 0);
            for (let r = 0; r < s; ++r) {
                const s = [r, ...o[r].map((t => t.j))];
                let i = a.from(s.map((e => t.row(e))));
                i = i.dot(h);
                const _ = i.dot(i.transpose()), {eigenvectors: c} = f(_, e), u = a.from(c),
                    d = u.transpose().dot(u).add(1 / Math.sqrt(n + 1));
                for (let t = 0; t < n + 1; ++t) for (let e = 0; e < n + 1; ++e) l.set_entry(s[t], s[e], l.entry(s[t], s[e]) - (t === e ? 1 : 0) + d.entry(t, e))
            }
            const {eigenvectors: _} = f(l, e + 1);
            return this.Y = a.from(_.slice(1)).transpose(), this.projection
        }
    }, t.MDS = m, t.Matrix = a, t.OPTICS = class {
        constructor(t, s, r, i = e) {
            return this._matrix = t, this._epsilon = s, this._min_points = r, this._metric = i, this._ordered_list = [], this._clusters = [], this._DB = new Array(t.shape[0]).fill(), this.init(), this
        }

        init() {
            const t = this._ordered_list, e = this._matrix, s = e.shape[0], r = this._DB, i = this._clusters;
            let n = this._cluster_index = 0;
            for (let t = 0; t < s; ++t) r[t] = {
                element: e.row(t),
                index: t,
                reachability_distance: void 0,
                processed: !1
            };
            for (const e of r) if (!e.processed && (e.neighbors = this._get_neighbors(e), e.processed = !0, i.push([e.index]), n = i.length - 1, t.push(e), null != this._core_distance(e))) {
                const t = new _(null, (t => t.reachability_distance), "min");
                this._update(e, t), this._expand_cluster(t, i[n])
            }
            return this
        }

        _get_neighbors(t) {
            if ("neighbors" in t) return t.neighbors;
            const e = this._DB, s = this._metric, r = this._epsilon, i = [];
            for (const n of e) n.index != t.index && s(t.element, n.element) < r && i.push(n);
            return i
        }

        _core_distance(t) {
            const e = this._min_points, s = this._metric;
            if (!(t.neighbors && t.neighbors.length <= e)) return s(t.element, t.neighbors[e].element)
        }

        _update(t, e) {
            const s = this._metric, r = this._core_distance(t), i = this._get_neighbors(t);
            for (const n of i) {
                if (n.processed) continue;
                const i = Math.max(r, s(t.element, n.element));
                e.raw_data().findIndex((t => t.element == n)) < 0 ? (n.reachability_distance = i, e.push(n)) : i < n.reachability_distance && (n.reachability_distance = i, e = _.heapify(e.data(), (t => t.reachability_distance), "min"))
            }
        }

        _expand_cluster(t, e) {
            const s = this._ordered_list;
            for (; !t.empty;) {
                const r = t.pop().element;
                r.neighbors = this._get_neighbors(r), r.processed = !0, e.push(r.index), s.push(r), null != this._core_distance(r) && (this._update(r, t), this._expand_cluster(t, e))
            }
        }

        get_clusters() {
            const t = [], e = [], s = this._min_points;
            for (const r of this._clusters) r.length < s ? e.push(...r) : t.push(r);
            return t.push(e), t
        }

        get_cluster_affirmation() {
            const t = this._matrix.shape[0], e = new Array(t).fill(), s = this.get_clusters();
            for (let t = 0, r = s.length; t < r; ++t) {
                const i = s[t];
                for (const s of i) e[s] = t < r - 1 ? t : -1
            }
            return e
        }
    }, t.PCA = p, t.Randomizer = l, t.TSNE = class extends d {
        constructor(t, s = 50, r = 10, i = 2, n = e, o = 1212) {
            return super(t, i, n, o), super.parameter_list = ["perplexity", "epsilon"], [this._N, this._D] = this.X.shape, this.parameter("perplexity", Math.min(s, this._N - 1)), this.parameter("epsilon", r), this._iter = 0, this.Y = new a(this._N, this._d, (() => this._randomizer.random)), this
        }

        init(t = null) {
            const e = Math.log(this._perplexity), s = this._N, r = this._D, i = this._metric, n = this.X;
            let o;
            if (t) o = t; else {
                o = new a(s, s);
                for (let t = 0; t < s; ++t) {
                    const e = n.row(t);
                    for (let r = t + 1; r < s; ++r) {
                        const s = i(e, n.row(r));
                        o.set_entry(t, r, s), o.set_entry(r, t, s)
                    }
                }
            }
            const h = new a(s, s, "zeros");
            this._ystep = new a(s, r, "zeros"), this._gains = new a(s, r, 1);
            let l = new Array(s).fill(0);
            for (let t = 0; t < s; ++t) {
                let r = -1 / 0, i = 1 / 0, n = 1, a = !1, _ = 0;
                for (; !a;) {
                    let h = 0;
                    for (let e = 0; e < s; ++e) {
                        let s = Math.exp(-o.entry(t, e) * n);
                        t === e && (s = 0), l[e] = s, h += s
                    }
                    let c = 0;
                    for (let t = 0; t < s; ++t) {
                        let e = 0 === h ? 0 : l[t] / h;
                        l[t] = e, e > 1e-7 && (c -= e * Math.log(e))
                    }
                    c > e ? (r = n, n = i === 1 / 0 ? 2 * n : (n + i) / 2) : (i = n, n = r === -1 / 0 ? n / 2 : (n + r) / 2), ++_, Math.abs(c - e) < 1e-4 && (a = !0), _ >= 50 && (a = !0)
                }
                for (let e = 0; e < s; ++e) h.set_entry(t, e, l[e])
            }
            const _ = new a(s, s, "zeros"), c = 2 * s;
            for (let t = 0; t < s; ++t) for (let e = t; e < s; ++e) {
                const s = Math.max((h.entry(t, e) + h.entry(e, t)) / c, 1e-100);
                _.set_entry(t, e, s), _.set_entry(e, t, s)
            }
            return this._P = _, this
        }

        transform(t = 500) {
            this.check_init();
            for (let e = 0; e < t; ++e) this.next();
            return this.projection
        }

        * generator() {
            for (this.check_init(); ;) this.next(), yield this.projection
        }

        next() {
            const t = ++this._iter, e = this._P, s = this._ystep, r = this._gains, i = this._N, n = this._epsilon,
                o = this._d;
            let h = this.Y;
            const l = t < 100 ? 4 : 1, _ = new a(i, i, "zeros");
            let c = 0;
            for (let t = 0; t < i; ++t) for (let e = t + 1; e < i; ++e) {
                let s = 0;
                for (let r = 0; r < o; ++r) {
                    const i = h.entry(t, r) - h.entry(e, r);
                    s += i * i
                }
                const r = 1 / (1 + s);
                _.set_entry(t, e, r), _.set_entry(e, t, r), c += 2 * r
            }
            const u = new a(i, i, 0);
            for (let t = 0; t < i; ++t) for (let e = t + 1; e < i; ++e) {
                const s = Math.max(_.entry(t, e) / c, 1e-100);
                u.set_entry(t, e, s), u.set_entry(e, t, s)
            }
            const f = new a(i, o, "zeros");
            for (let t = 0; t < i; ++t) for (let s = 0; s < i; ++s) {
                const r = 4 * (l * e.entry(t, s) - u.entry(t, s)) * _.entry(t, s);
                for (let e = 0; e < o; ++e) f.set_entry(t, e, f.entry(t, e) + r * (h.entry(t, e) - h.entry(s, e)))
            }
            let d = new Float64Array(o);
            for (let e = 0; e < i; ++e) for (let i = 0; i < o; ++i) {
                const o = f.entry(e, i), a = s.entry(e, i), l = r.entry(e, i);
                let _ = Math.sign(o) === Math.sign(a) ? .8 * l : l + .2;
                _ < .01 && (_ = .01), r.set_entry(e, i, _);
                const c = (t < 250 ? .5 : .8) * a - n * _ * o;
                s.set_entry(e, i, c), h.set_entry(e, i, h.entry(e, i) + c), d[i] += h.entry(e, i)
            }
            for (let t = 0; t < i; ++t) for (let e = 0; e < 2; ++e) h.set_entry(t, e, h.entry(t, e) - d[e] / i);
            return this.Y
        }
    }, t.TopoMap = class extends d {
        constructor(t, s = 2, r = e, i = 1212) {
            return super(t, s, r, i), super.parameter_list = [], [this._N, this._D] = this.X.shape, this._distance_matrix = new a(this._N, this._N, 0), this
        }

        __lazy_distance_matrix(t, e, s) {
            const r = this._distance_matrix, i = this.X, n = r.entry(t, e);
            if (0 === n) {
                let n = s(i.row(t), i.row(e));
                return r.set_entry(t, e, n), r.set_entry(e, t, n), n
            }
            return n
        }

        _make_minimum_spanning_tree(t = e) {
            const s = this._N, r = [...this.X];
            let i = new A(r);
            const n = [];
            let o = [];
            for (let e = 0; e < s; ++e) for (let r = e + 1; r < s; ++r) o.push([e, r, this.__lazy_distance_matrix(e, r, t)]);
            o = o.sort(((t, e) => t[2] - e[2]));
            for (const [t, e, s] of o) {
                const o = i.find(r[t]), h = i.find(r[e]);
                o !== h && (n.push([t, e, s]), i.union(o, h))
            }
            return n.sort(((t, e) => t[2] - e[2]))
        }

        init() {
            return this.Y = new a(this._N, this._d, 0), this._Emst = this._make_minimum_spanning_tree(this._metric), this._is_initialized = !0, this
        }

        __hull_cross([t, e], [s, r], [i, n]) {
            return (s - t) * (n - e) - (r - e) * (i - t) <= 0
        }

        __hull(t) {
            const e = t.sort((([t, e], [s, r]) => e - r || t - s)), s = e.length;
            if (s <= 2) return e;
            const r = [];
            for (let t = 0; t < s; ++t) {
                for (; r.length >= 2 && this.__hull_cross(r[r.length - 2], r[r.length - 1], e[t]);) r.pop();
                r.push(e[t])
            }
            const i = [];
            for (let t = s - 1; t >= 0; --t) {
                for (; i.length >= 2 && this.__hull_cross(i[i.length - 2], i[i.length - 1], e[t]);) i.pop();
                i.push(e[t])
            }
            return i.pop(), r.pop(), r.concat(i)
        }

        __findAngle([t, s], [r, i]) {
            const n = e([t, s], [r, i]);
            if (0 === n) return {sin: 0, cos: 1};
            const o = [(r - t) / n, (i - s) / n], h = o[0];
            let a = Math.sqrt(1 - h * h);
            return a = o[1] >= 0 ? -a : a, {sin: a, cos: h}
        }

        __align_hull(t, s, r) {
            let i, n, o, h = -1;
            for (let r = 0; r < t.length; ++r) {
                const n = e(t[r], s);
                (-1 === h || i > n) && (i = n, h = r)
            }
            r ? (n = t[h], o = t[(h + 1) % t.length]) : (0 == h && (h = t.length - 1), n = t[h], o = t[(h - 1) % t.length]);
            const a = {tx: -t[h][0], ty: -t[h][1]};
            if (t.length >= 2) {
                const {sin: t, cos: e} = this.__findAngle(n, o);
                a.sin = t, a.cos = e
            } else a.sin = 0, a.cos = 1;
            return a
        }

        __transform([t, e], {tx: s, ty: r, sin: i, cos: n}) {
            let o = t + s, h = e + r;
            return [o * n - h * i, o * i + h * n]
        }

        __transform_component(t, e, s) {
            const r = t.length;
            for (let i = 0; i < r; ++i) {
                const r = t[i], [n, o] = this.__transform(r, e);
                r[0] = n, r[1] = o + s
            }
        }

        __align_components = (t, e, s) => {
            const r = [...t.__disjoint_set.children], i = [...e.__disjoint_set.children], n = this.__hull(r),
                o = this.__hull(i), h = this.__align_hull(n, t, !1), a = this.__align_hull(o, e, !0);
            this.__transform_component(r, h, 0), this.__transform_component(i, a, s)
        };

        transform() {
            this._is_initialized || this.init();
            const t = this._Emst, e = [...this.Y], s = new A(e.map(((t, e) => (t.i = e, t))));
            for (const [r, i, n] of t) {
                const t = s.find(e[r]), o = s.find(e[i]);
                t !== o && (this.__align_components(t, o, n), s.union(t, o))
            }
            return this.projection
        }

        * generator() {
            this._is_initialized || this.init();
            const t = this._Emst, e = [...this.Y], s = new A(e.map(((t, e) => (t.i = e, t))));
            for (const [r, i, n] of t) {
                const t = s.find(e[r]), o = s.find(e[i]);
                t !== o && (this.__align_components(t, o, n), s.union(t, o), yield this.projection)
            }
            return this.projection
        }
    }, t.TriMap = class extends d {
        constructor(t, s = 500, r = 5, i = 2, n = e, o = 1212) {
            return super(t, i, n, o), super.parameter_list = ["weight_adj", "c"], this.parameter("weight_adj", s), this.parameter("c", r), this
        }

        init(t = null, e = null) {
            const s = this.X, r = s.shape[0], i = this._d, n = this._metric, o = this._c;
            this.n_inliers = 2 * o, this.n_outliers = 1 * o, this.n_random = 1 * o, this.Y = t || new p(s, i).transform(), this.knn = e || new c(s.to2dArray, n);
            const {triplets: h, weights: l} = this._generate_triplets(this.n_inliers, this.n_outliers, this.n_random);
            return this.triplets = h, this.weights = l, this.lr = 1e3 * r / h.shape[0], this.C = 1 / 0, this.tol = 1e-7, this.vel = new a(r, i, 0), this.gain = new a(r, i, 1), this
        }

        _generate_triplets(t, e, s) {
            const r = this._metric, i = this._weight_adj, n = this.X, o = n.shape[0], h = this.knn,
                l = Math.min(t + 20, o), _ = new a(o, l), c = new a(o, l);
            for (let t = 0; t < o; ++t) h.search(n.row(t), l + 1).raw_data().filter((t => 0 != t.value)).sort(((t, e) => t.value - e.value)).forEach(((e, s) => {
                _.set_entry(t, s, e.element.index), c.set_entry(t, s, e.value)
            }));
            const u = new Float64Array(o);
            for (let t = 0; t < o; ++t) u[t] = Math.max((c.entry(t, 3) + c.entry(t, 4) + c.entry(t, 5) + c.entry(t, 6)) / 4, 1e-10);
            const f = this._find_p(c, u, _);
            let d = this._sample_knn_triplets(f, _, t, e), p = d.shape[0];
            const m = new Float64Array(p);
            for (let t = 0; t < p; ++t) {
                const e = d.entry(t, 0), s = d.entry(t, 2);
                m[t] = r(n.row(e), n.row(s))
            }
            let y = this._find_weights(d, f, _, m, u);
            if (s > 0) {
                const {random_triplets: t, random_weights: e} = this._sample_random_triplets(n, s, u);
                d = d.concat(t, "vertical"), y = Float64Array.from([...y, ...e])
            }
            p = d.shape[0];
            let w = -1 / 0;
            for (let t = 0; t < p; ++t) isNaN(y[t]) && (y[t] = 0), w < y[t] && (w = y[t]);
            let g = -1 / 0;
            for (let t = 0; t < p; ++t) y[t] /= w, y[t] += 1e-4, y[t] = Math.log(1 + i * y[t]), g < y[t] && (g = y[t]);
            for (let t = 0; t < p; ++t) y[t] /= g;
            return {triplets: d, weights: y}
        }

        _find_p(t, e, s) {
            const [r, i] = t.shape;
            return new a(r, i, ((r, i) => Math.exp(-(t.entry(r, i) ** 2) / e[r] / e[s.entry(r, i)])))
        }

        _sample_knn_triplets(t, e, s, r) {
            const i = e.shape[0], n = new a(i * s * r, 3);
            for (let o = 0; o < i; ++o) {
                let h = o * s * r;
                const a = this.__argsort(t.row(o).map((t => -t)));
                for (let t = 0; t < s; ++t) {
                    let s = t * r;
                    const l = e.entry(o, a[t]), _ = this._rejection_sample(r, i, a.slice(0, t + 1));
                    for (let t = 0; t < r; ++t) {
                        const e = h + s + t, r = _[t];
                        n.set_entry(e, 0, o), n.set_entry(e, 1, l), n.set_entry(e, 2, r)
                    }
                }
            }
            return n
        }

        __argsort(t) {
            return t.map(((t, e) => ({d: t, i: e}))).sort(((t, e) => t.d - e.d)).map((t => t.i))
        }

        _rejection_sample(t, e, s) {
            const r = this._randomizer, i = o(0, e - 1).filter((t => s.indexOf(t) < 0));
            return r.choice(i, Math.min(t, i.length - 2))
        }

        _find_weights(t, e, s, r, i) {
            const n = t.shape[0], o = new Float64Array(n);
            for (let h = 0; h < n; ++h) {
                const n = t.entry(h, 0), a = s.row(n).indexOf(t.entry(h, 1)), l = e.entry(n, a);
                let _ = Math.exp(-(r[h] ** 2) / (i[n] * i[t.entry(h, 2)]));
                _ < 1e-20 && (_ = 1e-20), o[h] = l / _
            }
            return o
        }

        _sample_random_triplets(t, e, s) {
            const r = this._metric, i = this._randomizer, n = t.shape[0], h = new a(n * e, 3),
                l = new Float64Array(n * e);
            for (let a = 0; a < n; ++a) {
                const _ = a * e, c = [...o(0, a - 1), ...o(a + 1, n - 1)];
                for (let n = 0; n < e; ++n) {
                    let [e, o] = i.choice(c, 2), u = Math.exp(-(r(t.row(a), t.row(e)) ** 2) / (s[a] * s[e]));
                    u < 1e-20 && (u = 1e-20);
                    let f = Math.exp(-(r(t.row(a), t.row(o)) ** 2) / (s[a] * s[o]));
                    f < 1e-20 && (f = 1e-20), u < f && ([e, o] = [o, e], [u, f] = [f, u]);
                    const d = _ + n;
                    h.set_entry(d, 0, a), h.set_entry(d, 1, e), h.set_entry(d, 2, o), l[d] = u / f
                }
            }
            return {random_triplets: h, random_weights: l}
        }

        _grad(t) {
            const e = this.n_inliers, s = this.n_outliers, r = this.triplets, i = this.weights, [n, o] = t.shape,
                h = r.shape[0], l = new a(n, o, 0);
            let _ = new Array(o).fill(0), c = new Array(o).fill(0), u = 1, f = 1, d = 0, p = 0;
            const m = n * e * s;
            for (let e = 0; e < h; ++e) {
                const [n, h, a] = r.row(e);
                if (e % s == 0 || e >= m) {
                    u = 1, f = 1;
                    for (let e = 0; e < o; ++e) {
                        const s = t.entry(n, e), r = t.entry(h, e), i = t.entry(a, e);
                        _[e] = s - r, c[e] = s - i, u += _[e] ** 2, f += c[e] ** 2
                    }
                } else {
                    f = 1;
                    for (let e = 0; e < o; ++e) {
                        const s = t.entry(n, e), r = t.entry(a, e);
                        c[e] = s - r, f += c[e] ** 2
                    }
                }
                u > f && ++d, p += i[e] / (1 + f / u);
                const y = (i[e] / (u + f)) ** 2;
                for (let t = 0; t < o; ++t) {
                    const e = _[t] * f * y, s = c[t] * u * y;
                    l.set_entry(n, t, l.entry(n, t) + e - s), l.set_entry(h, t, l.entry(h, t) - e), l.set_entry(a, t, l.entry(a, t) + s)
                }
            }
            return {grad: l, loss: p, n_viol: d}
        }

        transform(t = 400) {
            this.check_init();
            for (let e = 0; e < t; ++e) this._next(e);
            return this.projection
        }

        * generator() {
            this.check_init();
            for (let t = 0; t < 800; ++t) this._next(t), yield this.projection;
            return this.projection
        }

        _next(t) {
            const e = t > 150 ? .5 : .3, s = this.C, r = this.vel, i = this.Y.add(r.mult(e)), {
                grad: n,
                loss: o,
                n_viol: h
            } = this._grad(i);
            return this.C = o, this.Y = this._update_embedding(i, t, n), this.lr *= s > o + this.tol ? 1.01 : .9, this.Y
        }

        _update_embedding(t, e, s) {
            const [r, i] = t.shape, n = e > 150 ? .9 : .5, o = this.gain, h = this.vel, a = this.lr;
            for (let e = 0; e < r; ++e) for (let r = 0; r < i; ++r) {
                const i = Math.sign(h.entry(e, r)) != Math.sign(s.entry(e, r)) ? o.entry(e, r) + .2 : Math.max(.8 * o.entry(e, r), .01);
                o.set_entry(e, r, i), h.set_entry(e, r, n * h.entry(e, r) - a * o.entry(e, r) * s.entry(e, r)), t.set_entry(e, r, t.entry(e, r) + h.entry(e, r))
            }
            return t
        }
    }, t.UMAP = class extends d {
        constructor(t, s = 1, r = 1, i = 2, n = e, o = 1212) {
            return super(t, i, n, o), super.parameter_list = ["local_connectivity", "min_dist"], [this._N, this._D] = this.X.shape, this.parameter("local_connectivity", s), this.parameter("min_dist", r), this._iter = 0, this._n_neighbors = Math.min(15, this._N - 1), this._spread = 1, this._set_op_mix_ratio = 1, this._repulsion_strength = 1, this._negative_sample_rate = 5, this._n_epochs = 350, this._initial_alpha = 1, this.Y = new a(this._N, this._d, (() => this._randomizer.random)), this
        }

        _find_ab_params(t, e) {
            for (var r = o(0, 3 * t, 300), i = o(0, 3 * t, 300), n = 0, h = r.length; n < h; ++n) r[n] < e ? i[n] = 1 : i[n] = Math.exp(-(r[n] - e) / t);
            var [a, l] = y((function (t) {
                var e = o(1, 300).map(((e, s) => i[s] - function (t, e, s) {
                    return 1 / (1 + e * Math.pow(t, 2 * s))
                }(r[s], t[0], t[1])));
                return Math.sqrt(s(e.map((t => t * t))))
            }), [1, 1]);
            return [a, l]
        }

        _compute_membership_strengths(t, e, s) {
            for (let r = 0, i = t.length; r < i; ++r) for (let i = 0, n = t[r].length; i < n; ++i) {
                let n = t[r][i].value - s[r], o = 1;
                n > 0 && (o = Math.exp(-n / e[r])), t[r][i].value = o
            }
            return t
        }

        _smooth_knn_dist(t, e) {
            const s = .001, r = this._local_connectivity, i = 1 * Math.log2(e), n = [], o = [], h = this.X;
            let a = [];
            for (let s = 0, i = h.shape[0]; s < i; ++s) {
                let i = h.row(s);
                a.push(t.search(i, Math.max(r, e)).raw_data().reverse())
            }
            for (let t = 0, r = h.shape[0]; t < r; ++t) {
                let r = a[t];
                n.push(r[0].value);
                let h = 0, l = 1 / 0, _ = 1;
                for (let s = 0; s < 64; ++s) {
                    let s = 0;
                    for (let i = 0; i < e; ++i) {
                        let e = r[i].value - n[t];
                        s += e > 0 ? Math.exp(-e / _) : 1
                    }
                    if (Math.abs(s - i) < 1e-5) break;
                    s > i ? (l = _, _ = (h + l) / 2) : (h = _, l === 1 / 0 ? _ *= 2 : _ = (h + l) / 2)
                }
                o[t] = _;
                const c = r.reduce(((t, e) => t + e.value), 0) / r.length;
                if (n[t] > 0) o[t] < s * c && (o[t] = s * c); else {
                    const e = a.reduce(((t, e) => t + e.reduce(((t, e) => t + e.value), 0) / e.length));
                    o[t] > s * e && (o[t] = s * e)
                }
            }
            return {distances: a, sigmas: o, rhos: n}
        }

        _fuzzy_simplicial_set(t, s) {
            const r = new c(t.to2dArray, e);
            let {distances: i, sigmas: n, rhos: o} = this._smooth_knn_dist(r, s);
            i = this._compute_membership_strengths(i, n, o);
            let h = new a(t.shape[0], t.shape[0], "zeros");
            for (let e = 0, r = t.shape[0]; e < r; ++e) for (let t = 0; t < s; ++t) h.set_entry(e, i[e][t].element.index, i[e][t].value);
            const l = h.T, _ = h.mult(l);
            return h = h.add(l).sub(_).mult(this._set_op_mix_ratio).add(_.mult(1 - this._set_op_mix_ratio)), h
        }

        _make_epochs_per_sample(t, e) {
            const {data: s} = this._tocoo(t);
            let r = new Array(s.length).fill(-1);
            const i = Math.max(...s), n = s.map((t => e * (t / i)));
            return r = r.map(((t, s) => n[s] > 0 ? Math.round(e / n[s]) : t)), r
        }

        _tocoo(t) {
            const e = [], s = [], r = [], [i, n] = t.shape;
            for (let o = 0; o < i; ++o) for (let i = 0; i < n; ++i) {
                const n = t.entry(o, i);
                0 !== n && (e.push(o), s.push(i), r.push(n))
            }
            return {rows: e, cols: s, data: r}
        }

        init() {
            const [t, e] = this._find_ab_params(this._spread, this._min_dist);
            this._a = t, this._b = e, this._graph = this._fuzzy_simplicial_set(this.X, this._n_neighbors), this._epochs_per_sample = this._make_epochs_per_sample(this._graph, this._n_epochs), this._epochs_per_negative_sample = this._epochs_per_sample.map((t => t * this._negative_sample_rate)), this._epoch_of_next_sample = this._epochs_per_sample.slice(), this._epoch_of_next_negative_sample = this._epochs_per_negative_sample.slice();
            const {rows: s, cols: r} = this._tocoo(this._graph);
            return this._head = s, this._tail = r, this
        }

        set local_connectivity(t) {
            this._local_connectivity = t
        }

        get local_connectivity() {
            return this._local_connectivity
        }

        set min_dist(t) {
            this._min_dist = t
        }

        get min_dist() {
            return this._min_dist
        }

        transform(t) {
            this.check_init(), t = t || this._n_epochs;
            for (let e = 0; e < t; ++e) this.next();
            return this.projection
        }

        * generator() {
            for (this.check_init(), this._iter = 0; this._iter < this._n_epochs;) this.next(), yield this.projection;
            return this.projection
        }

        _clip(t) {
            return t > 4 ? 4 : t < -4 ? -4 : t
        }

        _optimize_layout(t, s, r, i) {
            const {
                _d: n,
                _alpha: o,
                _repulsion_strength: h,
                _a: a,
                _b: l,
                _epochs_per_sample: _,
                _epochs_per_negative_sample: c,
                _epoch_of_next_negative_sample: u,
                _epoch_of_next_sample: f,
                _clip: d
            } = this, p = i.length;
            for (let m = 0, y = _.length; m < y; ++m) if (f[m] <= this._iter) {
                const y = r[m], w = i[m], g = t.row(y), A = s.row(w), x = e(g, A);
                let M = 0;
                x > 0 && (M = -2 * a * l * Math.pow(x, l - 1) / (a * Math.pow(x, l) + 1));
                for (let e = 0; e < n; ++e) {
                    const r = d(M * (g[e] - A[e])) * o, i = g[e] + r, n = A[e] - r;
                    g[e] = i, A[e] = n, t.set_entry(y, e, i), s.set_entry(w, e, n)
                }
                f[m] += _[m];
                const v = (this._iter - u[m]) / c[m];
                for (let r = 0; r < v; ++r) {
                    const r = Math.floor(this._randomizer.random * p), _ = s.row(i[r]), c = e(g, _);
                    let u = 0;
                    if (c > 0) u = 2 * h * l / ((.01 + c) * (a * Math.pow(c, l) + 1)); else if (y == r) continue;
                    for (let e = 0; e < n; ++e) {
                        const n = d(u * (g[e] - _[e])) * o, h = g[e] + n, a = _[e] - n;
                        g[e] = h, _[e] = a, t.set_entry(y, e, h), s.set_entry(i[r], e, a)
                    }
                }
                u[m] += v * c[m]
            }
            return t
        }

        next() {
            let t = ++this._iter, e = this.Y;
            return this._alpha = this._initial_alpha * (1 - t / this._n_epochs), this.Y = this._optimize_layout(e, e, this._head, this._tail), this.Y
        }
    }, t.canberra = function (t, e) {
        if (t.length !== e.length) return;
        let s = t.length, r = 0;
        for (let i = 0; i < s; ++i) r += Math.abs(t[i] - e[i]) / (Math.abs(t[i]) + Math.abs(e[i]));
        return r
    }, t.chebyshev = function (t, e) {
        if (t.length != e.length) return;
        let s = t.length, r = [];
        for (let i = 0; i < s; ++i) r.push(Math.abs(t[i] - e[i]));
        return Math.max(...r)
    }, t.cosine = function (t, e) {
        if (t.length !== e.length) return;
        let s = t.length, r = 0, i = 0, n = 0;
        for (let o = 0; o < s; ++o) r += t[o] * e[o], i += t[o] * t[o], n += e[o] * e[o];
        return Math.acos(r / (Math.sqrt(i) * Math.sqrt(n)))
    }, t.distance_matrix = n, t.euclidean = e, t.euclidean_squared = r, t.k_nearest_neighbors = i, t.kahan_sum = function (t) {
        let e, s, r = t.length, i = 0, n = 0;
        for (let o = 0; o < r; ++o) e = t[o] - n, s = i + e, n = s - i - e, i = s;
        return i
    }, t.linspace = o, t.manhattan = function (t, e) {
        if (t.length != e.length) return;
        let s = t.length, r = 0;
        for (let i = 0; i < s; ++i) r += Math.abs(t[i] - e[i]);
        return r
    }, t.neumair_sum = s, t.norm = h, t.powell = y, t.qr = u, t.simultaneous_poweriteration = f, t.version = "0.3.5", Object.defineProperty(t, "__esModule", {value: !0})
}));
